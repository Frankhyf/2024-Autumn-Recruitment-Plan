User
int fib(int N) {
    if (N < 1) return 0;
    // 备忘录全初始化为 0
    vector<int> memo(N + 1, 0);
    // 初始化最简情况
    return helper(memo, N);
}

int helper(vector<int>& memo, int n) {
    // base case 
    if (n == 1 || n == 2) return 1;
    // 已经计算过
    if (memo[n] != 0) return memo[n];
    memo[n] = helper(memo, n - 1) + 
                helper(memo, n - 2);
    return memo[n];
}
解释一下这个算法

ChatGPT
这 C++ 程序实现了计算斐波那契数列的第 N 个数。斐波那契数列是一个著名的数列，其中每个数字是前两个数字的和，通常以 0, 1, 1, 2, 3, 5, 8, ... 开始。

程序中的两个函数 fib 和 helper 一起工作来计算斐波那契数列的第 N 个数字。

fib 函数
参数： N，表示要计算斐波那契数列的第 N 个数。
逻辑：
如果 N 小于 1，返回 0。这是因为斐波那契数列从 0 开始。
它初始化一个名为 memo 的向量（动态数组），用于存储已经计算过的斐波那契数。这是为了避免重复计算，提高效率。
调用 helper 函数，并传入 memo 和 N 作为参数。
helper 函数
参数： memo，一个存储已计算斐波那契数的数组；n，表示当前要计算的斐波那契数的位置。
逻辑：
基础情况（Base Case）： 当 n 为 1 或 2 时，直接返回 1，因为斐波那契数列的前两个数字是 1。
查找备忘录： 如果 memo[n] 不为 0，表示这个位置的斐波那契数已经被计算过了，直接返回该值。
递归计算： 如果上述情况都不符合，它计算 n-1 和 n-2 的斐波那契数，并将结果存储在 memo[n] 中，以便将来使用。
返回计算得到的斐波那契数。
总的来说，这个算法利用了动态规划的方法，通过存储已经计算过的结果来避免重复计算，从而提高了效率。这种方法被称为“备忘录”或“记忆化搜索”。


`vector` 是 C++ 标准模板库（STL）中的一种容器，它可以被看作是一个动态数组。与普通数组相比，它可以自动管理存储空间，使得元素的添加和删除更加灵活和高效。

### 由来
`vector` 是 C++ STL 的一部分。STL 是一套强大的 C++ 标准库，包含了一系列预定义的模板类和函数，旨在提高软件开发效率，`vector` 作为其中的一员，广泛用于需要动态数组功能的场合。

### 特性
1. **动态大小：** `vector` 可以在运行时改变大小，自动处理内存的分配和释放。
2. **随机访问：** 可以通过索引直接访问元素，类似于普通数组。
3. **灵活性：** 提供了多种操作方法，如添加、删除、遍历等。
4. **内存管理：** 自动管理内存，使用者不需要担心内存分配和释放的问题。

### 用法
基本用法包括：
- 声明：`vector<DataType> vec;`
- 添加元素：`vec.push_back(value);`
- 访问元素：`vec[index];`
- 获取大小：`vec.size();`

### 具体语句解释
```cpp
vector<int> memo(N + 1, 0);
```
这行代码在程序中的作用是：

- 创建一个 `int` 类型的 `vector`，名为 `memo`。
- `memo` 的大小被设置为 `N + 1`。这意味着它包含 `N + 1` 个整数。
- 初始化：每个元素都被初始化为 `0`。这是由于 `vector` 的构造函数接受两个参数：第一个参数指定了 `vector` 的大小，第二个参数是用于初始化 `vector` 中每个元素的值。

在上述代码的上下文中，这个 `vector` 被用作备忘录（memoization）来存储斐波那契数列中每个位置上的值。这样可以避免重复计算同一个位置的斐波那契数，从而显著提高算法的效率。

int fib(int N) {  
    vector<int> dp(N + 1, 0);  
    // base case  
    dp[1] = dp[2] = 1;  
    for (int i = 3; i <= N; i++)  
        dp[i] = dp[i - 1] + dp[i - 2];  
    return dp[N];  
}
创建一个DP数组，每个格子算之前两个格子数字之和
						
int fib(int n) {  
    if (n == 2 || n == 1)   
        return 1;  
    int prev = 1, curr = 1;  
    for (int i = 3; i <= n; i++) {  
        int sum = prev + curr;  
        prev = curr;  
        curr = sum;  
    }  
    return curr;  
}
不要数组，直接把前两个状态记录一下就行